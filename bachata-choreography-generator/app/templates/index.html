{% extends "base.html" %}

{% block title %}Bachata Choreography Generator{% endblock %}

{% block content %}
<div class="min-h-screen flex items-center justify-center p-4" x-data="choreographyGenerator()">
    <div class="bg-white/95 backdrop-blur-sm rounded-3xl shadow-2xl p-8 max-w-2xl w-full animate-fade-in">
        <!-- Header -->
        <div class="text-center mb-8">
            <h2 class="text-4xl font-bold text-gray-900 mb-4">
                Create Your Choreography
            </h2>
            <p class="text-gray-600 text-lg">
                Generate personalized dance sequences from your favorite Bachata songs
            </p>
        </div>
        
        <!-- Main Form -->
        <div x-show="!isGenerating && !result && !error" x-transition:enter="transition ease-out duration-300">
            <div class="space-y-6">
                
                <!-- Song Selection -->
                <div>
                    <label for="song_selection" class="block text-sm font-semibold text-gray-700 mb-3">
                        Select Song
                    </label>
                    <select id="song_selection" 
                            x-model="selectedSong"
                            @change="toggleYouTubeInput()"
                            class="w-full px-4 py-3 border-2 border-gray-200 rounded-xl focus:ring-2 focus:ring-primary-500 focus:border-transparent transition-all duration-200 text-gray-900">
                        <option value="">Choose a song...</option>
                        <option value="data/songs/Amor.mp3">Amor</option>
                        <option value="data/songs/Angel.mp3">Angel</option>
                        <option value="data/songs/Aventura.mp3">Aventura</option>
                        <option value="data/songs/Besito.mp3">Besito</option>
                        <option value="data/songs/Bubalu.mp3">Bubalu</option>
                        <option value="data/songs/Chayanne.mp3">Chayanne</option>
                        <option value="data/songs/Corazoncandado.mp3">Coraz√≥n Candado</option>
                        <option value="data/songs/Delmar.mp3">Del Mar</option>
                        <option value="data/songs/Desnudate.mp3">Desn√∫date</option>
                        <option value="data/songs/Emborrachare.mp3">Me Emborrachar√©</option>
                        <option value="data/songs/Nas.mp3">Old Town Road (Bachata)</option>
                        <option value="data/songs/Secreto.mp3">Este Secreto</option>
                        <option value="data/songs/Suegra.mp3">Suegra</option>
                        <option value="data/songs/Temevas.mp3">Te Me Vas</option>
                        <option value="data/songs/Veneno.mp3">Veneno</option>
                        <option value="new_song">New song (YouTube URL)</option>
                    </select>
                </div>
                
                <!-- YouTube URL Input -->
                <div x-show="selectedSong === 'new_song'" 
                     x-transition:enter="transition ease-out duration-300"
                     x-transition:enter-start="opacity-0 transform -translate-y-2"
                     x-transition:enter-end="opacity-100 transform translate-y-0">
                    <label for="youtube_url" class="block text-sm font-semibold text-gray-700 mb-3">
                        YouTube URL
                    </label>
                    <input type="url" 
                           id="youtube_url" 
                           x-model="youtubeUrl"
                           placeholder="https://www.youtube.com/watch?v=..."
                           class="w-full px-4 py-3 border-2 border-gray-200 rounded-xl focus:ring-2 focus:ring-primary-500 focus:border-transparent transition-all duration-200">
                </div>
                
                <div id="generation-response"></div>
                
                <!-- Generate Button -->
                <button @click="submitChoreographyRequest()" 
                        :disabled="!canGenerate()"
                        class="w-full bg-gradient-to-r from-primary-500 to-secondary-500 text-white py-4 rounded-xl font-bold text-lg hover:from-primary-600 hover:to-secondary-600 transition-all duration-200 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none">
                    <span x-show="!isGenerating">Create Choreography</span>
                    <span x-show="isGenerating" class="flex items-center justify-center">
                        <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        Generating...
                    </span>
                </button>
            </div>
        </div>
        
        <!-- Progress Display -->
        <div x-show="isGenerating" 
             x-transition:enter="transition ease-out duration-300"
             class="space-y-6">
            
            <div class="text-center">
                <h3 class="text-2xl font-bold text-gray-900 mb-2">Generating Your Choreography</h3>
                <p class="text-gray-600" x-text="progressMessage">Starting...</p>
                <p class="text-sm text-gray-500 mt-2">This usually takes 20-30 seconds</p>
            </div>
            
            <!-- Progress Bar -->
            <div class="w-full bg-gray-200 rounded-full h-4 overflow-hidden">
                <div class="bg-gradient-to-r from-primary-500 to-secondary-500 h-4 rounded-full transition-all duration-500 ease-out"
                     :style="`width: ${progress}%`"></div>
            </div>
            
            <div class="text-center">
                <span class="text-2xl font-bold text-primary-600" x-text="`${progress}%`"></span>
            </div>
            
            <!-- Manual refresh button for connection issues -->
            <div class="text-center">
                <button @click="checkTaskStatus()" 
                        class="text-sm text-gray-500 hover:text-gray-700 underline">
                    Check Status Manually
                </button>
            </div>
        </div>
        
        <!-- Results Display -->
        <div x-show="result" 
             x-transition:enter="transition ease-out duration-300"
             class="space-y-6">
            
            <div class="text-center">
                <h3 class="text-2xl font-bold text-green-600 mb-4">üéâ Choreography Complete!</h3>
            </div>
            
            <!-- Video Player -->
            <div class="text-center">
                <video x-show="result" 
                       x-ref="videoPlayer"
                       :src="result ? `/api/video/${result.video_filename}` : ''"
                       @loadedmetadata="initVideoPlayer()"
                       @timeupdate="updateProgress()"
                       @ended="handleVideoEnd()"
                       @click="togglePlayPause()"
                       class="w-full max-w-lg mx-auto rounded-xl shadow-lg">
                    Your browser does not support the video tag.
                </video>
            </div>
            
            <!-- Custom Video Controls -->
            <div x-show="result" class="max-w-lg mx-auto space-y-3">
                <!-- Basic Play/Pause Controls -->
                <div class="flex items-center justify-center space-x-4 mb-3">
                    <button @click="togglePlayPause()" 
                            class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg font-semibold transition-colors duration-200">
                        <span x-show="!isPlaying">‚ñ∂Ô∏è Play</span>
                        <span x-show="isPlaying">‚è∏Ô∏è Pause</span>
                    </button>
                    
                    <button @click="seekTo(0)" 
                            class="px-3 py-2 bg-gray-500 hover:bg-gray-600 text-white rounded-lg font-semibold transition-colors duration-200">
                        ‚èÆÔ∏è Inicio
                    </button>
                </div>

                <!-- Progress Bar -->
                <div x-show="videoDuration > 0" class="space-y-2">
                    <div class="flex justify-between text-sm text-gray-600">
                        <span x-text="formatTime(currentTime)">0:00</span>
                        <span x-text="formatTime(videoDuration)">0:00</span>
                    </div>
                    
                    <!-- Progress bar container -->
                    <div class="relative bg-gray-300 h-2 rounded-full cursor-pointer" @click="seekToPosition($event)">
                        <!-- Progress indicator -->
                        <div class="bg-blue-500 h-2 rounded-full transition-all duration-100"
                             :style="`width: ${progressPercentage}%`"></div>
                        
                        <!-- Loop segment indicator -->
                        <div x-show="loopStart >= 0 && loopEnd > loopStart" 
                             class="absolute top-0 h-2 bg-green-400 rounded-full opacity-70"
                             :style="`left: ${loopStartPercentage}%; width: ${loopSegmentWidth}%`"></div>
                    </div>
                </div>

                <!-- Loop Controls -->
                <div class="flex items-center justify-center space-x-4">
                    <button @click="toggleLoop()" 
                            :class="isLooping ? 'bg-green-500 hover:bg-green-600' : 'bg-gray-500 hover:bg-gray-600'"
                            class="px-4 py-2 text-white rounded-lg font-semibold transition-colors duration-200">
                        <span x-show="!isLooping">üîÑ Activar Loop</span>
                        <span x-show="isLooping">‚èπÔ∏è Desactivar Loop</span>
                    </button>
                </div>

                <!-- Loop Segment Info -->
                <div x-show="loopStart >= 0 && loopEnd > loopStart" 
                     class="bg-green-50 border border-green-200 rounded-lg p-3">
                    <div class="text-sm text-green-800">
                        <p><strong>Segmento de Loop:</strong> <span x-text="formatTime(loopStart)"></span> - <span x-text="formatTime(loopEnd)"></span></p>
                        <p><strong>Duraci√≥n:</strong> <span x-text="formatTime(loopEnd - loopStart)"></span></p>
                    </div>
                    
                    <!-- Fine Adjustment Controls -->
                    <div class="flex items-center justify-center space-x-8 mt-3">
                        <div class="flex flex-col items-center space-y-2">
                            <span class="text-sm font-medium text-gray-700">Inicio</span>
                            <div class="flex space-x-2">
                                <button @click="adjustLoopStart(-5)" 
                                        class="px-3 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg font-semibold transition-colors duration-200">
                                    ‚è™ -5s
                                </button>
                                <button @click="adjustLoopStart(5)" 
                                        class="px-3 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg font-semibold transition-colors duration-200">
                                    ‚è© +5s
                                </button>
                            </div>
                        </div>
                        <div class="flex flex-col items-center space-y-2">
                            <span class="text-sm font-medium text-gray-700">Fin</span>
                            <div class="flex space-x-2">
                                <button @click="adjustLoopEnd(-5)" 
                                        class="px-3 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg font-semibold transition-colors duration-200">
                                    ‚è™ -5s
                                </button>
                                <button @click="adjustLoopEnd(5)" 
                                        class="px-3 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg font-semibold transition-colors duration-200">
                                    ‚è© +5s
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Result Info -->
            <div class="bg-gray-50 rounded-xl p-6 space-y-3">
                <h4 class="font-bold text-gray-900 text-lg">Generation Details</h4>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
                    <div class="text-center">
                        <p class="text-gray-600">Processing Time</p>
                        <p class="font-semibold text-gray-900" x-text="result ? `${result.processing_time.toFixed(1)}s` : ''"></p>
                    </div>
                    <div class="text-center">
                        <p class="text-gray-600">Sequence Duration</p>
                        <p class="font-semibold text-gray-900" x-text="result ? `${result.sequence_duration.toFixed(1)}s` : ''"></p>
                    </div>
                    <div class="text-center">
                        <p class="text-gray-600">Moves Analyzed</p>
                        <p class="font-semibold text-gray-900" x-text="result ? result.moves_analyzed : ''"></p>
                    </div>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="flex flex-col sm:flex-row gap-4">
                <template x-if="$root.user.isAuthenticated">
                    <button @click="saveToCollection()" 
                            class="flex-1 bg-green-500 hover:bg-green-600 text-white py-3 rounded-xl font-semibold transition-colors duration-200">
                        Save to Collection
                    </button>
                </template>
                
                <button @click="resetForm()" 
                        class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-3 rounded-xl font-semibold transition-colors duration-200">
                    Generate Another
                </button>
            </div>
        </div>
        
        <!-- Error Display -->
        <div x-show="error" 
             x-transition:enter="transition ease-out duration-300"
             class="space-y-6">
            
            <div class="bg-red-50 border-2 border-red-200 rounded-xl p-6 text-center">
                <div class="text-red-600 mb-4">
                    <svg class="w-16 h-16 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
                    </svg>
                </div>
                <h3 class="text-xl font-bold text-red-800 mb-2">Generation Failed</h3>
                <p class="text-red-700" x-text="errorMessage"></p>
            </div>
            
            <button @click="resetForm()" 
                    class="w-full bg-red-500 hover:bg-red-600 text-white py-3 rounded-xl font-semibold transition-colors duration-200">
                Try Again
            </button>
        </div>
    </div>
</div>

{% endblock %}

{% block extra_scripts %}
<script>
    function choreographyGenerator() {
        return {
            // Form state
            selectedSong: '',
            youtubeUrl: '',
            
            // Generation state
            isGenerating: false,
            currentTaskId: null,
            pollInterval: null,
            progress: 0,
            progressMessage: 'Starting...',
            
            // Results
            result: null,
            error: false,
            errorMessage: '',
            
            // Video player state
            videoDuration: 0,
            currentTime: 0,
            progressPercentage: 0,
            isPlaying: false,
            
            // Loop functionality
            isLooping: false,
            loopStart: -1,
            loopEnd: -1,
            
            // Computed properties for loop indicators
            get loopStartPercentage() {
                if (this.videoDuration > 0 && this.loopStart >= 0) {
                    return (this.loopStart / this.videoDuration) * 100;
                }
                return 0;
            },
            
            get loopSegmentWidth() {
                if (this.videoDuration > 0 && this.loopStart >= 0 && this.loopEnd > this.loopStart) {
                    return ((this.loopEnd - this.loopStart) / this.videoDuration) * 100;
                }
                return 0;
            },
            
            // Form validation
            canGenerate() {
                if (this.selectedSong === 'new_song') {
                    return this.youtubeUrl.trim() !== '';
                }
                return this.selectedSong !== '';
            },
            
            // Toggle YouTube input visibility
            toggleYouTubeInput() {
                if (this.selectedSong !== 'new_song') {
                    this.youtubeUrl = '';
                }
            },
            
            // Get the YouTube URL for the API
            getYoutubeUrl() {
                if (this.selectedSong === 'new_song') {
                    return this.youtubeUrl;
                }
                return this.selectedSong;
            },
            
            // Submit choreography request
            async submitChoreographyRequest() {
                if (!this.canGenerate()) {
                    return;
                }
                
                this.startGeneration();
                
                try {
                    const requestData = {
                        youtube_url: this.getYoutubeUrl(),
                        difficulty: 'intermediate',
                        quality_mode: 'balanced'
                    };
                    
                    // Add timeout for initial request (10 seconds should be enough to start the task)
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000);
                    
                    const response = await fetch('/api/choreography', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(requestData),
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        const result = await response.json();
                        this.currentTaskId = result.task_id;
                        this.progressMessage = 'Generation started, analyzing music...';
                        this.startPolling();
                    } else {
                        const errorData = await response.json();
                        this.handleApiError(errorData, response.status);
                    }
                } catch (error) {
                    console.error('Error submitting choreography request:', error);
                    if (error.name === 'AbortError') {
                        this.showError('Request timed out. Please try again.');
                    } else {
                        this.showError('Failed to connect to server. Please try again.');
                    }
                }
            },
            
            // Handle API errors
            handleApiError(errorData, status) {
                let errorMsg = 'Failed to start generation. Please try again.';
                
                try {
                    // Handle different error formats
                    if (errorData.detail) {
                        if (typeof errorData.detail === 'string') {
                            errorMsg = errorData.detail;
                        } else if (Array.isArray(errorData.detail)) {
                            // Validation errors from FastAPI
                            const validationErrors = errorData.detail.map(err => 
                                `${err.loc ? err.loc.join('.') + ': ' : ''}${err.msg}`
                            ).join(', ');
                            errorMsg = `Validation error: ${validationErrors}`;
                        } else if (errorData.detail.message) {
                            errorMsg = errorData.detail.message;
                        }
                    } else if (errorData.message) {
                        errorMsg = errorData.message;
                    }
                } catch (e) {
                    console.error('Error parsing error response:', e);
                    errorMsg = `Server error (${status}). Please try again.`;
                }
                
                this.showError(errorMsg);
            },
            
            // Start generation process
            startGeneration() {
                this.isGenerating = true;
                this.result = null;
                this.error = false;
                this.progress = 0;
                this.progressMessage = 'Starting generation...';
            },
            
            // Start polling for progress
            startPolling() {
                if (this.pollInterval) {
                    clearInterval(this.pollInterval);
                }
                
                let pollAttempts = 0;
                const maxPollAttempts = 3; // Allow 3 consecutive failures before giving up
                let consecutiveFailures = 0;
                
                this.pollInterval = setInterval(async () => {
                    if (!this.currentTaskId) return;
                    
                    try {
                        // Increase timeout for fetch request to 30 seconds
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 30000);
                        
                        const response = await fetch(`/api/task/${this.currentTaskId}`, {
                            signal: controller.signal
                        });
                        
                        clearTimeout(timeoutId);
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const status = await response.json();
                        
                        // Reset failure counter on successful request
                        consecutiveFailures = 0;
                        
                        // Update progress
                        this.progress = status.progress || 0;
                        this.progressMessage = status.message || 'Processing...';
                        
                        // Check if completed
                        if (status.status === 'completed') {
                            this.stopPolling();
                            this.showResult(status.result);
                        } else if (status.status === 'failed') {
                            this.stopPolling();
                            this.showError(status.error || status.message || 'Generation failed');
                        }
                        
                    } catch (error) {
                        consecutiveFailures++;
                        console.warn(`Polling attempt ${consecutiveFailures} failed:`, error);
                        
                        // Only show error after multiple consecutive failures
                        if (consecutiveFailures >= maxPollAttempts) {
                            console.error('Max polling failures reached:', error);
                            this.stopPolling();
                            this.showError('Connection lost. The generation may still be running - please check back in a few minutes.');
                        } else {
                            // Update progress message to show we're retrying
                            this.progressMessage = `Connection issue, retrying... (${consecutiveFailures}/${maxPollAttempts})`;
                        }
                    }
                }, 2000); // Increased polling interval to 2 seconds to reduce server load
            },
            
            // Stop polling
            stopPolling() {
                if (this.pollInterval) {
                    clearInterval(this.pollInterval);
                    this.pollInterval = null;
                }
            },
            
            // Manual status check
            async checkTaskStatus() {
                if (!this.currentTaskId) return;
                
                try {
                    const response = await fetch(`/api/task/${this.currentTaskId}`);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const status = await response.json();
                    
                    // Update progress
                    this.progress = status.progress || 0;
                    this.progressMessage = status.message || 'Processing...';
                    
                    // Check if completed
                    if (status.status === 'completed') {
                        this.stopPolling();
                        this.showResult(status.result);
                    } else if (status.status === 'failed') {
                        this.stopPolling();
                        this.showError(status.error || status.message || 'Generation failed');
                    } else {
                        // If still running, restart polling
                        this.startPolling();
                    }
                    
                } catch (error) {
                    console.error('Error checking task status:', error);
                    this.progressMessage = 'Connection issue - please try again';
                }
            },
            
            // Show results
            showResult(resultData) {
                this.isGenerating = false;
                this.result = resultData;
                this.error = false;
                
                // Show success notification
                this.$root.showNotification('Choreography generated successfully!', 'success');
            },
            
            // Show error
            showError(message) {
                this.isGenerating = false;
                this.error = true;
                this.errorMessage = message;
                this.result = null;
                
                // Show error notification
                this.$root.showNotification(message, 'error');
            },
            
            // Video player functions
            togglePlayPause() {
                const video = this.$refs.videoPlayer;
                if (video) {
                    if (video.paused) {
                        // Si el loop est√° activo y hay un segmento seleccionado, empezar desde el inicio del loop
                        if (this.isLooping && this.loopStart >= 0) {
                            video.currentTime = this.loopStart;
                        }
                        video.play();
                        this.isPlaying = true;
                    } else {
                        video.pause();
                        this.isPlaying = false;
                    }
                }
            },

            seekTo(time) {
                const video = this.$refs.videoPlayer;
                if (video) {
                    video.currentTime = time;
                }
            },

            initVideoPlayer() {
                const video = this.$refs.videoPlayer;
                if (video) {
                    this.videoDuration = video.duration;
                    this.currentTime = video.currentTime;
                    this.isPlaying = !video.paused;
                    this.updateProgress();
                }
            },

            updateProgress() {
                const video = this.$refs.videoPlayer;
                if (video) {
                    this.currentTime = video.currentTime;
                    this.progressPercentage = (video.currentTime / video.duration) * 100;
                    this.isPlaying = !video.paused;
                    
                    // Check if we need to loop
                    if (this.isLooping && this.loopEnd > 0 && video.currentTime >= this.loopEnd) {
                        video.currentTime = this.loopStart;
                    }
                }
            },

            handleVideoEnd() {
                this.isPlaying = false;
                if (this.isLooping && this.loopStart >= 0) {
                    const video = this.$refs.videoPlayer;
                    if (video) {
                        video.currentTime = this.loopStart;
                        video.play();
                    }
                }
            },

            seekToPosition(event) {
                const video = this.$refs.videoPlayer;
                if (video && this.videoDuration > 0) {
                    const rect = event.currentTarget.getBoundingClientRect();
                    const clickX = event.clientX - rect.left;
                    const percentage = clickX / rect.width;
                    const newTime = percentage * this.videoDuration;
                    video.currentTime = newTime;
                }
            },

            // Loop functionality
            toggleLoop() {
                this.isLooping = !this.isLooping;
                
                // Si activamos el loop y hay un segmento seleccionado, mover el video al inicio del segmento
                if (this.isLooping && this.loopStart >= 0) {
                    const video = this.$refs.videoPlayer;
                    if (video) {
                        video.currentTime = this.loopStart;
                    }
                }
            },

            selectCurrent10Seconds() {
                const video = this.$refs.videoPlayer;
                if (video && this.videoDuration > 0) {
                    this.loopStart = Math.max(0, this.currentTime - 5);
                    this.loopEnd = Math.min(this.videoDuration, this.currentTime + 5);
                }
            },

            adjustLoopStart(seconds) {
                if (this.loopStart >= 0) {
                    this.loopStart = Math.max(0, Math.min(this.loopStart + seconds, this.loopEnd - 1));
                }
            },

            adjustLoopEnd(seconds) {
                if (this.loopEnd > 0) {
                    this.loopEnd = Math.min(this.videoDuration, Math.max(this.loopEnd + seconds, this.loopStart + 1));
                }
            },

            formatTime(seconds) {
                if (isNaN(seconds) || seconds < 0) return '0:00';
                const minutes = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${minutes}:${secs.toString().padStart(2, '0')}`;
            },
            
            // Reset form
            resetForm() {
                this.selectedSong = '';
                this.youtubeUrl = '';
                this.isGenerating = false;
                this.result = null;
                this.error = false;
                this.progress = 0;
                this.progressMessage = 'Starting...';
                this.currentTaskId = null;
                
                // Reset video player state
                this.videoDuration = 0;
                this.currentTime = 0;
                this.progressPercentage = 0;
                this.isPlaying = false;
                this.isLooping = false;
                this.loopStart = -1;
                this.loopEnd = -1;
                
                this.stopPolling();
            },
            
            // Save to collection (requires authentication)
            async saveToCollection() {
                if (!this.result || !this.$root.user.isAuthenticated) {
                    this.$root.showNotification('Please login to save choreographies', 'warning');
                    return;
                }
                
                try {
                    const response = await fetch('/api/collection/save', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.$root.user.token}`
                        },
                        body: JSON.stringify({
                            title: `Choreography - ${new Date().toLocaleDateString()}`,
                            video_filename: this.result.video_filename,
                            metadata: {
                                song: this.selectedSong === 'new_song' ? this.youtubeUrl : this.selectedSong,
                                processing_time: this.result.processing_time,
                                sequence_duration: this.result.sequence_duration,
                                moves_analyzed: this.result.moves_analyzed
                            }
                        })
                    });
                    
                    if (response.ok) {
                        this.$root.showNotification('Choreography saved to your collection!', 'success');
                    } else {
                        throw new Error('Failed to save choreography');
                    }
                } catch (error) {
                    console.error('Error saving to collection:', error);
                    this.$root.showNotification('Failed to save choreography. Please try again.', 'error');
                }
            },
            
            // Cleanup on destroy
            destroy() {
                this.stopPolling();
            }
        }
    }
</script>
{% endblock %}